{	
	"View Header Comment": {
		"prefix": "sqlViewHeaderComment",
		"body": [
		"/* v_LP_ ",
		"",
		"Requestor: ", 
		"Author: Jared Duquette ",
		"Consuming Platform: ",
		"Created on: MM-DD-YY",
		"",
		"Purpose:",
		"",
		"",
		"*****Change Log*****",
		"",
		"Last Update        Name             Change Summary",
		"MM-DD-YY           DUQ               summaryHere",
		"",
		"",
		"",
		"*/ "
		],
		"description": "Provides standard view comment block"
	},
	"Recent Query": {
		"prefix": "sqlRecentQuery",
		"body": [
			"SELECT dest.TEXT AS [Query],",
			"deqs.execution_count [Count],",
			"deqs.last_execution_time AS [Time]",
			"FROM sys.dm_exec_query_stats AS deqs",
			"CROSS APPLY sys.dm_exec_sql_text(deqs.sql_handle) AS dest",
			"ORDER BY deqs.last_execution_time DESC"
		],
		"description": "Provides list of recent query execution."
	}, 
	"Row Count for Table": {
		"prefix": "sqlRowCounts", 
		"body": [
			"-- Performs a full table scan. Slow on large tables.",
			"SELECT COUNT(*) FROM tableName ",
			"-- Fast way to retrieve row count. Depends on statistics and is inaccurate.",
			"-- Run DBCC UPDATEUSAGE(Database) WITH COUNT_ROWS, which can take significant time for large tables.",
			"SELECT CONVERT(bigint, rows)",
			"FROM sysindexes",
			"WHERE id = OBJECT_ID('tableName')",
			"AND indid < 2",
			"-- The way the SQL management studio counts rows (look at table properties, storage, row count). Very fast, but still an approximate number of rows.",
			"SELECT CAST(p.rows AS float)",
			"FROM sys.tables AS tbl",
			"INNER JOIN sys.indexes AS idx ON idx.object_id = tbl.object_id and idx.index_id < 2",
			"INNER JOIN sys.partitions AS p ON p.object_id=CAST(tbl.object_id AS int)",
			"AND p.index_id=idx.index_id",
			"WHERE ((tbl.name=N'tableName'",
			"AND SCHEMA_NAME(tbl.schema_id)='dbo'))",
			"-- Quick (although not as fast as method 2) operation and equally important, reliable.",
			"SELECT SUM (row_count)",
			"FROM sys.dm_db_partition_stats",
			"WHERE object_id=OBJECT_ID('Transactions')  ",
			"AND (index_id=0 or index_id=1);"
		],
		"description": "4 ways to get row count on large tables"
	}, 
	"Create db schema": {
		"prefix": "sqlCreateSchema", 
		"body": [
			"CREATE SCHEMA [schemaNameHere]", 
			"GO", 
			"", 
			"-- Run this query to see schema", 
			"-- SELECT * FROM sys.schemas;"
		], 
		"description": "Create and view db schema."
	}, 
	"Data stuff": {
		"prefix": "sqlDataTypeInfo", 
		"body": [
			"SELECT",
			"column_name, data_type, CHARACTER_MAXIMUM_LENGTH, COLLATION_NAME",
			"-- distinct TABLE_SCHEMA, TABLE_NAME",
			"FROM INFORMATION_SCHEMA.COLUMNS",
			"WHERE",
			"TABLE_SCHEMA IN ('')",
			"AND TABLE_NAME IN ('')",  
			"AND COLUMN_NAME IN ('')"
		], 
		"description": "What is the collation/data type length for a column?"
	}, 
	"Index info": {
		"prefix": "sqlIndexInfo", 
		"body": [
			"SELECT TableName = t.name, IndexName = ind.name, IndexId = ind.index_id, ColumnId = ic.index_column_id, ColumnName = col.name",
			"--,ind.*, ic.*, col.* ",
			"FROM sys.indexes AS ind ",
			"INNER JOIN sys.index_columns ic ON ( ind.object_id = ic.object_id and ind.index_id = ic.index_id )",
			"INNER JOIN sys.columns AS col ON ( ic.object_id = col.object_id and ic.column_id = col.column_id )",
			"INNER JOIN sys.tables AS t ON ( ind.object_id = t.object_id )",
			"ORDER BY t.name, ind.name, ind.index_id, ic.index_column_id;"
		],
		"description": "What index are there - provides the names of index for quick alter"
	}, 
	"MERGE statement": {
		"prefix": "sqlMERGE",
		"body": [
			"MERGE target_schema.target_table AS tgt ",
			"USING source_schema.staging AS srs ON ( ",
			"\tsrs.id = tgt.id ",
			")",
			"WHEN MATCHED THEN UPDATE SET ",
			"\ttgt.column_name = srs.column_name",
			"WHEN NOT MATCHED BY TARGET THEN INSERT ( ",
			"\tcolumn_name ",
			")",
			"VALUES ( ",
			"\tsrs.column_name ",
			")",
			"WHEN NOT MATCHED BY SOURCE THEN DELETE;"
		],
		"description": "MERGE statement syntax"
	},
	"INSERT from SELECT": {
		"prefix": "sqlInsertSelect",
		"body": [
			"INSERT INTO target_table ( column_1, column_n )",
			"SELECT column_1, column_N FROM source_table;"
		],
		"description": "INSERT from SELECT"
	}, 
	"Try/Catch": {
		"prefix": "sqlTryCatch",
		"body": [
			"BEGIN TRY",
			"END TRY",
			"BEGIN CATCH",
			"\tEXECUTE tools.usp_transformation_log",
			"\t\t@object_id = @@PROCID,", 
			"\t\t@row_count = @@ROWCOUNT,",
			"\t\t@message = 'step in code'",
			"\t;",
			"END CATCH" 
		],
		"description": "Wrap code in Try/Catch and write to custom transformation log for internal audits."
	}, 
	"Drop Temp Table": {
		"prefix": "sqlDropTempTable",
		"body": [
			"IF OBJECT_ID(N'tempdb..#TableName') IS NOT NULL",
			"BEGIN",
			"DROP TABLE #TableName",
			"END"
		],
		"description": "Drop a temp table"
	}
	 
}