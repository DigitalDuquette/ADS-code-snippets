{	
	"View Header Comment": {
		"prefix": "sqlViewHeaderComment",
		"body": [
		"/* v_LP_ ",
		"",
		"Requestor: ", 
		"Author: Jared Duquette ",
		"Consuming Platform: ",
		"Created on: MM-DD-YY",
		"",
		"Purpose:",
		"",
		"",
		"*****Change Log*****",
		"",
		"Last Update        Name             Change Summary",
		"MM-DD-YY           DUQ               summaryHere",
		"",
		"",
		"",
		"*/ "
		],
		"description": "Provides standard view comment block"
	},
	"Stored Proc Header Comment": {
		"prefix": "sqlCommentProcHeader",
		"body": [
			"/***************************************************************************************************",
			"Procedure:          dbo.usp_DoSomeStuff",
			"GitHub Repo:        PADNOS/Salesforce_Extensibility ",
			"Create Date:        2018-01-25",
			"Author:             Joe Expert",
			"Description:        Verbose description of what the query does goes here. Be specific and don't be",
			"\t\t\t\t\tafraid to say too much. More is better, than less, every single time. Think about",
			"\t\t\t\t\t``what, when, where, how and why`` when authoring a description.",
			"Call by:            [schema.usp_ProcThatCallsThis]",
			"\t\t\t\t\t[Application Name]",
			"\t\t\t\t\t[Job]",
			"\t\t\t\t\t[PLC/Interface]",
			"Affected table(s):  [schema.TableModifiedByProc1]",
			"\t\t\t\t\t[schema.TableModifiedByProc2]",
			"Used By:            Functional Area this is use in, for example, Payroll, Accounting, Finance",
			"Parameter(s):       @param1 - description and usage",
			"\t\t\t\t\t@param2 - description and usage",
			"Usage:              EXEC dbo.usp_DoSomeStuff",
			"\t\t\t\t\t@param1 = 1,",
			"\t\t\t\t\t@param2 = 3,",
			"\t\t\t\t\t@param3 = 2",
			"\t\t\t\t\tAdditional notes or caveats about this object, like where is can and cannot be run, or",
			"\t\t\t\t\tgotchas to watch for when using it.",
			"****************************************************************************************************",
			"SUMMARY OF CHANGES",
			"Date(yyyy-mm-dd)    Author              Comments",
			"------------------- ------------------- ------------------------------------------------------------",
			"2012-04-27          John Usdaworkhur    Move Z <-> X was done in a single step. Warehouse does not",
			"\t\t\t\t\tallow this. Converted to two step process.",
			"\t\t\t\t\tZ <-> 7 <-> X",
			"\t\t\t\t\t1) move class Z to class 7",
			"\t\t\t\t\t2) move class 7 to class X",
			"",
			"2018-03-22          Maan Widaplan       General formatting and added header information.",
			"2018-03-22          Maan Widaplan       Added logic to automatically Move G <-> H after 12 months.",
			"***************************************************************************************************/"
		],
		"description": "Header comment block for stored procs"
	},
	"Recent Query": {
		"prefix": "sqlRecentQuery",
		"body": [
			"SELECT dest.TEXT AS [Query],",
			"deqs.execution_count [Count],",
			"deqs.last_execution_time AS [Time]",
			"FROM sys.dm_exec_query_stats AS deqs",
			"CROSS APPLY sys.dm_exec_sql_text(deqs.sql_handle) AS dest",
			"ORDER BY deqs.last_execution_time DESC"
		],
		"description": "Provides list of recent query execution."
	}, 
	"Row Count for Table": {
		"prefix": "sqlRowCounts", 
		"body": [
			"-- Performs a full table scan. Slow on large tables.",
			"SELECT COUNT(*) FROM tableName ",
			"-- Fast way to retrieve row count. Depends on statistics and is inaccurate.",
			"-- Run DBCC UPDATEUSAGE(Database) WITH COUNT_ROWS, which can take significant time for large tables.",
			"SELECT CONVERT(bigint, rows)",
			"FROM sysindexes",
			"WHERE id = OBJECT_ID('tableName')",
			"AND indid < 2",
			"-- The way the SQL management studio counts rows (look at table properties, storage, row count). Very fast, but still an approximate number of rows.",
			"SELECT CAST(p.rows AS float)",
			"FROM sys.tables AS tbl",
			"INNER JOIN sys.indexes AS idx ON idx.object_id = tbl.object_id and idx.index_id < 2",
			"INNER JOIN sys.partitions AS p ON p.object_id=CAST(tbl.object_id AS int)",
			"AND p.index_id=idx.index_id",
			"WHERE ((tbl.name=N'tableName'",
			"AND SCHEMA_NAME(tbl.schema_id)='dbo'))",
			"-- Quick (although not as fast as method 2) operation and equally important, reliable.",
			"SELECT SUM (row_count)",
			"FROM sys.dm_db_partition_stats",
			"WHERE object_id=OBJECT_ID('Transactions')  ",
			"AND (index_id=0 or index_id=1);"
		],
		"description": "4 ways to get row count on large tables"
	}, 
	"Create db schema": {
		"prefix": "sqlCreateSchema", 
		"body": [
			"CREATE SCHEMA [schemaNameHere];", 
			"", 
			"-- Run this query to see schema", 
			"-- SELECT * FROM sys.schemas;"
		], 
		"description": "Create and view db schema."
	}, 
	"Data stuff": {
		"prefix": "sqlDataTypeInfo", 
		"body": [
			"SELECT",
			"\tCOLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, COLLATION_NAME",
			"\t-- distinct TABLE_SCHEMA, TABLE_NAME",
			"FROM INFORMATION_SCHEMA.COLUMNS",
			"WHERE",
			"\tTABLE_SCHEMA IN ('')",
			"\tAND TABLE_NAME IN ('')",  
			"\tAND COLUMN_NAME IN ('')"
		], 
		"description": "What is the collation/data type length for a column?"
	}, 
	"Index info": {
		"prefix": "sqlIndexInfo", 
		"body": [
			"SELECT TableName = t.name, IndexName = ind.name, IndexId = ind.index_id, ColumnId = ic.index_column_id, ColumnName = col.name",
			"--,ind.*, ic.*, col.* ",
			"FROM sys.indexes AS ind ",
			"INNER JOIN sys.index_columns ic ON ( ind.object_id = ic.object_id and ind.index_id = ic.index_id )",
			"INNER JOIN sys.columns AS col ON ( ic.object_id = col.object_id and ic.column_id = col.column_id )",
			"INNER JOIN sys.tables AS t ON ( ind.object_id = t.object_id )",
			"ORDER BY t.name, ind.name, ind.index_id, ic.index_column_id;"
		],
		"description": "What index are there - provides the names of index for quick alter"
	}, 
	"MERGE statement": {
		"prefix": "sqlMERGE",
		"body": [
			"MERGE target_schema.target_table AS tgt ",
			"\tUSING source_schema.staging AS srs ON ( ",
			"\t\tsrs.id = tgt.id ",
			"\t)",
			"\tWHEN MATCHED THEN UPDATE ",
			"\t\tSET ",
			"\t\t\ttgt.column_name = srs.column_name",
			"\tWHEN NOT MATCHED BY TARGET THEN ",
			"\t\tINSERT ( ",
			"\t\t\tcolumn_name ",
			"\t\t)",
			"\t\tVALUES ( ",
			"\t\t\tsrs.column_name ",
			"\t\t)",
			"\tWHEN NOT MATCHED BY SOURCE THEN ",
			"\t\tDELETE",
			";"
		],
		"description": "MERGE statement syntax"
	},
	"INSERT from SELECT": {
		"prefix": "sqlInsertSelect",
		"body": [
			"INSERT INTO target_table ( column_1, column_n )",
			"SELECT column_1, column_N FROM source_table;"
		],
		"description": "INSERT from SELECT"
	}, 
	"Try/Catch": {
		"prefix": "sqlTryCatch",
		"body": [
			"BEGIN TRY",
			"END TRY",
			"BEGIN CATCH",
			"\tEXECUTE tools.usp_transformation_log",
			"\t\t@object_id = @@PROCID,", 
			"\t\t@row_count = @@ROWCOUNT,",
			"\t\t@message = 'step in code'",
			"\t;",
			"END CATCH" 
		],
		"description": "Wrap code in Try/Catch and write to custom transformation log for internal audits."
	}, 
	"Drop Temp Table": {
		"prefix": "sqlDropTempTable",
		"body": [
			"IF OBJECT_ID(N'tempdb..#TableName') IS NOT NULL",
			"BEGIN",
			"DROP TABLE #TableName",
			"END"
		],
		"description": "Drop a temp table"
	}, 
	"Grant EXEC": {
		"prefix": "sqlGrantEXEC",
		"body": [
			"USE database_name;",
			"",
			"GRANT EXECUTE ON OBJECT::schema.usp_proc_name  ",
			"\tTO user_name ",
			"; "
		], 
		"description": "Grant execute on object to user via t-sql."
	}, 
	"Space Used": {
		"prefix": "sqlTableSize", 
		"body": [
			"USE database_name;",
			"EXEC sp_spaceused N'schema.table_name'; "
		],
		"description": "See size of a table."
	}, 
	"Maintain Grain": {
		"prefix": "sqlMaintainGrain", 
		"body": [
			"INSERT INTO schema.destination_table ( column1, column2 )",
			"\tSELECT s.column1, s.column2",
			"\tFROM schema.source_table AS s",
			"\t\tLEFT OUTER JOIN schema.destination_table AS d ON (",
			"\t\t\ts.column1 = d.column1",
			"\t\t\tAND s.column2 = d.column2",
			"\t\t)",
			"\tWHERE (",
			"\t\td.column1 IS NULL",
			"\t\tAND d.column2 IS NULL",
			"\t)",
			";",
			"DELETE FROM schema.destination_table",
			"\tWHERE",
			"\tNOT EXISTS (",
			"\t\t\tSELECT",
			"\t\t\t\ts.column1,",
			"\t\t\t\ts.column2",
			"\t\t\tFROM schema.source_table AS s",
			"\t\t\tWHERE",
			"\t\t\t\ts.column1 = destination_table.column1",
			"\t\t\t\tAND s.column2 = destination_table.column2",
			"\t\t)",
			";"
		], 
		"description": "Stop using MERGE. Use Insert and Delete to maintain grain instead."
	},
	"UTC Datetime to Local": {
		"prefix": "sqlDateUTCtoLocal",
		"body": [
			"CONVERT( /*replace SYSUTCDDATETIME() with UTC column*/",
			"\tdatetime,", 
			"\tSWITCHOFFSET(",
			"\t\tSYSUTCDATETIME(), ",
			"\t\tDATEPART(TZOFFSET, SYSUTCDATETIME() AT TIME ZONE 'Eastern Standard Time')",
			"\t)",
			") as converted_datetime "
		],
		"description": "Stop using GETDATE(), use SYSUTCDATETIME() and use your UTC dates in local time."
	}
	 
}